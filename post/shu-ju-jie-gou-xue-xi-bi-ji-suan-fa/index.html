<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>数据结构学习笔记--算法 | 蘑菇大陆</title>
<link rel="shortcut icon" href="https://blog.wutao.xyz/favicon.ico?v=1585131831441">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://blog.wutao.xyz/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="数据结构学习笔记--算法 | 蘑菇大陆 - Atom Feed" href="https://blog.wutao.xyz/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="算法定义
算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作；
特性：输入、输出、有穷性、确定性和可行性；
输入输出
算法具有零个或者多个输入，算法至少有一个或者多个输出；
有穷性
指算法在执行..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://blog.wutao.xyz">
  <img class="avatar" src="https://blog.wutao.xyz/images/avatar.png?v=1585131831441" alt="">
  </a>
  <h1 class="site-title">
    蘑菇大陆
  </h1>
  <p class="site-description">
    一个收集金币的管道工
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              数据结构学习笔记--算法
            </h2>
            <div class="post-info">
              <span>
                2015-03-18
              </span>
              <span>
                4 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h3 id="算法定义">算法定义</h3>
<p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作；<br>
特性：输入、输出、有穷性、确定性和可行性；</p>
<h4 id="输入输出">输入输出</h4>
<p>算法具有零个或者多个输入，算法至少有一个或者多个输出；</p>
<h4 id="有穷性">有穷性</h4>
<p>指算法在执行有限的步骤之后，自动结束而不会出现无线循环，并且每一个步骤在可接受的时间内完成；</p>
<h4 id="确定性">确定性</h4>
<p>算法的每一步骤都具有确定的含义，不会出现二义性。</p>
<h4 id="可行性">可行性</h4>
<p>算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限的次数完成。</p>
<h3 id="算法的数据要求">算法的数据要求</h3>
<h4 id="正确性">正确性</h4>
<p>算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义、能正确反映问题的需求、能够得到问题的正确答案；</p>
<ul>
<li>算法程序没有语法错误；</li>
<li>算法程序对于合法的输入数据能够产生满足要求的输出结果；</li>
<li>算法程序对于非法的输入数据能够得出满足规格说明的结果；</li>
<li>算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果；</li>
</ul>
<h4 id="可读性">可读性</h4>
<p>算法设计的另一目的是为了便于阅读、理解和交流；</p>
<h4 id="健壮性">健壮性</h4>
<p>当输入数据不合法时，书法也能做出相关处理，而不是产生异常或者莫名其妙的结果；</p>
<h4 id="时间效率高和存储量低">时间效率高和存储量低</h4>
<h3 id="算法效率的度量方法">算法效率的度量方法</h3>
<ul>
<li>
<p>事后统计法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低；</p>
</li>
<li>
<p>事前分析估算方法： 在计算机程序编制钱，依据统计方法对算法进行估算；</p>
</li>
</ul>
<h3 id="函数的渐近增长">函数的渐近增长</h3>
<p>输入规模 n 在没有限制的情况下，只要超过一个数值 N，这个函数就总大于另一个函数，称这个函数是渐进增长的；</p>
<p>给定两个函数 f(n) 和 g(n)，如果存在一个整数 N，使得对于所有的 n&gt;N，f(n) 总比 g(n) 大，那么，我们说 f(n) 的增长渐近快鱼 g(n)；</p>
<p>判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数；</p>
<h3 id="算法时间复杂度">算法时间复杂度</h3>
<p>在进行算法分析时，语句执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间量度记作 T(n) = O(f(n))。它表示随问题规模 n 的增大算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函数。</p>
<ul>
<li>一般情况下 随着 n 的增大， T(n) 增长最慢的算法称为最优算法；</li>
</ul>
<h4 id="推导大-o-阶方法">推导大 O 阶方法</h4>
<p>1、用常数 1 取代运行时间中的所有加法常数；<br>
2、在修改后的运行次数函数中，只保留最高阶项；<br>
3、如果最高阶项存在且不是 1，则去除与这个项相乘的常数；<br>
4、得到的结果就是大 O 阶。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E5%AE%9A%E4%B9%89">算法定义</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">输入输出</a></li>
<li><a href="#%E6%9C%89%E7%A9%B7%E6%80%A7">有穷性</a></li>
<li><a href="#%E7%A1%AE%E5%AE%9A%E6%80%A7">确定性</a></li>
<li><a href="#%E5%8F%AF%E8%A1%8C%E6%80%A7">可行性</a></li>
</ul>
</li>
<li><a href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A6%81%E6%B1%82">算法的数据要求</a>
<ul>
<li><a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a></li>
<li><a href="#%E5%8F%AF%E8%AF%BB%E6%80%A7">可读性</a></li>
<li><a href="#%E5%81%A5%E5%A3%AE%E6%80%A7">健壮性</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E6%95%88%E7%8E%87%E9%AB%98%E5%92%8C%E5%AD%98%E5%82%A8%E9%87%8F%E4%BD%8E">时间效率高和存储量低</a></li>
</ul>
</li>
<li><a href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F%E6%96%B9%E6%B3%95">算法效率的度量方法</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E6%B8%90%E8%BF%91%E5%A2%9E%E9%95%BF">函数的渐近增长</a></li>
<li><a href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">算法时间复杂度</a>
<ul>
<li><a href="#%E6%8E%A8%E5%AF%BC%E5%A4%A7-o-%E9%98%B6%E6%96%B9%E6%B3%95">推导大 O 阶方法</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://blog.wutao.xyz/post/shu-ju-jie-gou-xue-xi-bi-ji-ji-chu-gai-nian/">
              <h3 class="post-title">
                数据结构学习笔记--基础概念
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://blog.wutao.xyz/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
