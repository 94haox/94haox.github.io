<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.wutao.xyz</id>
    <title>Gridea</title>
    <updated>2020-03-21T08:52:17.890Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.wutao.xyz"/>
    <link rel="self" href="https://blog.wutao.xyz/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://blog.wutao.xyz/images/avatar.png</logo>
    <icon>https://blog.wutao.xyz/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[写在 FunnyFM 上线两个月后]]></title>
        <id>https://blog.wutao.xyz/post/xie-zai-funnyfm-shang-xian-liang-ge-yue-hou/</id>
        <link href="https://blog.wutao.xyz/post/xie-zai-funnyfm-shang-xian-liang-ge-yue-hou/">
        </link>
        <updated>2019-10-11T07:51:59.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="写在-funnyfm-上线两个月后">写在 FunnyFM 上线两个月后</h1>
<p>FunnyFM 是一款实用的 Podcast 客户端。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="写在-funnyfm-上线两个月后">写在 FunnyFM 上线两个月后</h1>
<p>FunnyFM 是一款实用的 Podcast 客户端。</p>
<!-- more -->
<p>它被我立项的原因是 iOS 自带的 Podcast 客户端在添加多个泛用型 RSS 播客后会非常的卡顿，在我的主力机 iPhoneX 上必现卡死。所以我萌发了自己做一款好用，流畅的 Podcast 客户端。</p>
<h2 id="开发周期">开发周期</h2>
<p>FunnyFM 仓库的创建是在 18年的11月9号，正式上线时间是在19年的8月14号。时间跨度非常的长。<br>
主要原因有几个：<br>
1、初期没有上线计划，纯粹自娱自乐；<br>
2、有上线计划后，功能过于简单，UI过于简陋，没有上线欲望；<br>
3、UI 基本靠自己画；<br>
4、将 rss 的解析由本地迁移到服务端，也就是说，自己承担了产品，UI，后端，iOS开发这4个角色；<br>
5、期间由于公司有个大的需求，开发时间较少。</p>
<h2 id="技术选型">技术选型</h2>
<h4 id="app-端">App 端</h4>
<p>这个没什么好说的，基于学习的原因，选择使用了 Swift， 本身没有上线 Android 平台的计划，所以并没有考虑混合开发，虽然 flutter 很🔥。</p>
<h4 id="后端">后端</h4>
<p>这个也没啥可说的，主要决定用 node.js,  选型主要是在几个框架中选择。经过比较后，egg.js 成为我的选择，原因主要是阿里开源，在阿里内部有使用，插件较多，在国内使用者比较多。</p>
<h4 id="前端">前端</h4>
<p>我爱 Vue。</p>
<h4 id="设计工具">设计工具</h4>
<p>Sketch ， &quot;灵感&quot;来源 Dribbble 😂。</p>
<h4 id="遇到的困难">遇到的困难</h4>
<p>1、需求变动<br>
由于初期并没有详细的规划，所以需求变动较快，也比较大，总想做一个成熟的版本一次性上架。</p>
<p>2、设计变动<br>
本身并不专业，只能在没有版权的作品中进行部分调整。多个模块有多次 UI 变动。</p>
<p>3、服务端<br>
起初的设想只是有一个账户系统，用来同步不同设备中的订阅功能。后续又添加了推送服务，推送服务又牵扯到 RSS 的抓取和判别，在加上最近计划的订阅服务，还有权限问题。</p>
<p>4、移动端<br>
目前在做的分享页，需要添加接口，也增加了工作量。</p>
<p>5、宣传<br>
完全没有做，只在 V2EX 发了一个贴😂。</p>
<h4 id="后期计划">后期计划</h4>
<p>目前已经更新 9 个版本，两个月内，平均一周一个版本，有时候更短，主要是由于缺乏测试，在收到崩溃报告时，需要快速解决和上架💔。</p>
<p>目前是买断制，正在计划转为订阅制。</p>
<p>正在进行的和后续的计划有：</p>
<p>分享功能，分享页。<br>
官方通知系统。<br>
订阅系统和账号系统关联。<br>
用户等级的划分。<br>
泛用型播客源的自主添加。<br>
添加推送页。</p>
<h4 id="总结">总结</h4>
<p>通过这篇文章来记录 FunnyFM 的前世今生，也记录一下全栈开发的艰辛，独立开发者是真的辛苦！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一些提升用户体验的 iOS 原生音视频特性]]></title>
        <id>https://blog.wutao.xyz/post/yi-xie-ti-sheng-yong-hu-ti-yan-de-ios-yuan-sheng-yin-shi-pin-te-xing/</id>
        <link href="https://blog.wutao.xyz/post/yi-xie-ti-sheng-yong-hu-ti-yan-de-ios-yuan-sheng-yin-shi-pin-te-xing/">
        </link>
        <updated>2019-08-18T11:43:38.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>最近在为自己开发一款泛用型播客工具 FunnyFm，在开发过程中发现了许多细节性的功能点，一些需要自己实现，一些 iOS 原生提供实现。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>最近在为自己开发一款泛用型播客工具 FunnyFm，在开发过程中发现了许多细节性的功能点，一些需要自己实现，一些 iOS 原生提供实现。</p>
 <!-- more --> 
<p>以下是在开发者文档中发现的一些用得着的原生特性。</p>
<h3 id="章节功能">章节功能</h3>
<p>大多数的播客工具中，如果音频源提供 <code>Chapter</code>， 那么你可以通过读取元数据中的章节信息来自定义章节选择界面。</p>
<pre><code class="language-swift">let asset = AVAsset(url: &lt;# Asset URL #&gt;)
let chapterLocalesKey = &quot;availableChapterLocales&quot;
 
asset.loadValuesAsynchronously(forKeys: [chapterLocalesKey]) {
    var error: NSError?
    let status = asset.statusOfValue(forKey: chapterLocalesKey, error: &amp;error)
    if status == .loaded {
        let languages = Locale.preferredLanguages
        let chapterMetadata = asset.chapterMetadataGroups(bestMatchingPreferredLanguages: languages)
        // Process chapter metadata
    }
    else {
        // Handle other status cases
    }
}
</code></pre>
<p>和</p>
<pre><code class="language-swift">func convertTimedMetadataGroupsToChapters(groups: [AVTimedMetadataGroup]) -&gt; [Chapter] {
    return groups.map { group -&gt; Chapter in
        // Retrieve AVMetadataCommonIdentifierTitle metadata items
        let titleItems = AVMetadataItem.metadataItems(from: group.items, filteredByIdentifier: AVMetadataCommonIdentifierTitle)
 
        // Retrieve AVMetadataCommonIdentifierTitle metadata items
        let artworkItems = AVMetadataItem.metadataItems(from: group.items, filteredByIdentifier: AVMetadataCommonIdentifierArtwork)

        var title = &quot;Default Title&quot;
        var image = UIImage(named: &quot;placeholder&quot;)!

        if let titleValue = titleItems.first?.stringValue {
            title = titleValue
        }

        if let imgData = artworkItems.first?.dataValue, imageValue = UIImage(data: imgData) {
            image = imageValue
        }

        return Chapter(time: group.timeRange.start, title: title, image: image)
    }
}
</code></pre>
<h3 id="媒体选项">媒体选项</h3>
<p>AVKit和AVFoundation提供了呈现字幕和隐藏式字幕以及选择其他音频和视频轨道的功能。如果您正在构建自己的自定义播放器或想要提供自己的媒体选择界面，则可以使用AVFoundation AVMediaSelectionGroup和AVMediaSelectionOption类提供的功能。</p>
<p>AVMediaSelectionOption封装了资源元数据里提供的可供选择的，音频，视频，文字。媒体选项用来实现选择可替换相机的角度，选择本地化语言，显示字幕或隐藏式字幕。可以通过availableMediaCharacteristicsWithMediaSelectionOptions来获得播放资源支持哪些选项。</p>
<p>获取支持的字幕</p>
<pre><code class="language-swift">for characteristic in asset.availableMediaCharacteristicsWithMediaSelectionOptions {
 
    print(&quot;\(characteristic)&quot;)
    // Retrieve the AVMediaSelectionGroup for the specified characteristic.
    if let group = asset.mediaSelectionGroup(forMediaCharacteristic: characteristic) {
        // Print its options.
        for option in group.options {
            print(&quot;  Option: \(option.displayName)&quot;)
        }
    }
}
</code></pre>
<p>获取媒体选项</p>
<pre><code class="language-swift">if let group = asset.mediaSelectionGroup(forMediaCharacteristic: AVMediaCharacteristicLegible) {
    let locale = Locale(identifier: &quot;es-ES&quot;)
    let options =
        AVMediaSelectionGroup.mediaSelectionOptions(from: group.options, with: locale)
    if let option = options.first {
        // Select Spanish-language subtitle option
        playerItem.select(option, in: group)
    }
}
</code></pre>
<h3 id="后台播放和远程控制">后台播放和远程控制</h3>
<p>对于后台播放，如果使用 AVPlayerViewController 进入后台时，需要做一些特殊配置：</p>
<pre><code class="language-swift">func applicationDidEnterBackground(_ application: UIApplication) {
    // If presenting video with AVPlayerViewController
    playerViewController.player = nil
    // If presenting video with AVPlayerLayer
    playerLayer.player = nil
}
 
func applicationWillEnterForeground(_ application: UIApplication) {
    // If presenting video with AVPlayerViewController
    playerViewController.player = player
    // If presenting video with AVPlayerLayer
    playerLayer.player = player
}
</code></pre>
<p>快捷面板的信息配置：</p>
<pre><code class="language-swift">		var info = Dictionary&lt;String, Any&gt;()
		info[MPMediaItemPropertyTitle] = ?//歌名
		info[MPMediaItemPropertyArtist] = ? //作者
        info[MPMediaItemPropertyArtwork] = MPMediaItemArtwork.init(boundsSize: size, requestHandler: { (size) -&gt; UIImage in
            if image.isSome{ return image! }
            return UIImage.init(named: &quot;ImagePlaceHolder&quot;)!
        })
		info[MPNowPlayingInfoPropertyAssetURL] = ?
		info[MPMediaItemPropertyPlaybackDuration] = self.totalTime
		info[MPNowPlayingInfoPropertyPlaybackRate] = 1.0
        info[MPNowPlayingInfoPropertyElapsedPlaybackTime] = self.currentTime
		info[MPMediaItemPropertySkipCount] = NSNumber.init(value: 15)
		MPNowPlayingInfoCenter.default().nowPlayingInfo = info
        UIApplication.shared.registerForRemoteNotifications()
</code></pre>
<p>远程控制的配置信息：</p>
<pre><code class="language-swift">        // 前进跳转文本显示时间间隔
		MPRemoteCommandCenter.shared().skipBackwardCommand.preferredIntervals = [15.0]
        // 后退跳转文本显示时间间隔
		MPRemoteCommandCenter.shared().skipForwardCommand.preferredIntervals = [15.0]
        // 前进按钮响应事件
		MPRemoteCommandCenter.shared().skipForwardCommand.addTarget { (event) -&gt; MPRemoteCommandHandlerStatus in
            // do something
			return .success
		}
		// 后退按钮响应事件
		MPRemoteCommandCenter.shared().skipBackwardCommand.addTarget { (event) -&gt; MPRemoteCommandHandlerStatus in
			// do something
			return .success
		}
		// 播放按钮响应事件
		MPRemoteCommandCenter.shared().playCommand.addTarget { (event) -&gt; MPRemoteCommandHandlerStatus in
			// do something
			return .success
		}
		// 暂停按钮响应事件
		MPRemoteCommandCenter.shared().pauseCommand.addTarget { (event) -&gt; MPRemoteCommandHandlerStatus in
			// do something
			return .success
		}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ APP 的一次启动优化]]></title>
        <id>https://blog.wutao.xyz/post/app-de-yi-ci-qi-dong-you-hua/</id>
        <link href="https://blog.wutao.xyz/post/app-de-yi-ci-qi-dong-you-hua/">
        </link>
        <updated>2019-08-03T06:27:28.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>当 App 迭代到一定阶段，业务逐渐增多，项目不断变大，启动时间优化是一个必经的阶段，这篇文章，我将从启动过程来提出几个优化点。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>当 App 迭代到一定阶段，业务逐渐增多，项目不断变大，启动时间优化是一个必经的阶段，这篇文章，我将从启动过程来提出几个优化点。</p>
<!-- more -->
<p>强烈建议观看 wwdc 2016 相关视频 <a href="https://developer.apple.com/videos/play/wwdc2016/406/">Optimizing App Startup Time</a></p>
<h1 id="开始">开始</h1>
<p>先放两个启动时间对比，只是一般的数据，精准度没有很高，但是两个在同种条件下的耗时还是具有一定对比性.</p>
<pre><code>// 一个新建的工程在 pre-main 期间的耗时数据
Total pre-main time:  85.98 milliseconds (100.0%)
         dylib loading time:  35.28 milliseconds (41.0%)
        rebase/binding time:  12.73 milliseconds (14.8%)
            ObjC setup time:   4.40 milliseconds (5.1%)
           initializer time:  33.56 milliseconds (39.0%)
</code></pre>
<pre><code>// 苏宁智能的耗时数据
Total pre-main time: 1.7 seconds (100.0%)
         dylib loading time: 418.45 milliseconds (23.9%)
        rebase/binding time: 111.41 milliseconds (6.3%)
            ObjC setup time: 413.69 milliseconds (23.6%)
           initializer time: 802.37 milliseconds (45.9%)
</code></pre>
<p>接下来，我们从上面的 log 开始分析在 App 启动过程中，做了哪些事情。</p>
<h3 id="app-启动流程">APP 启动流程</h3>
<p>这里的启动特指「冷启动」，这种启动是一种完整的启动流程，包括系统的进程创建。</p>
<h4 id="启动时系统都做了那些事">启动时，系统都做了那些事？</h4>
<p>从用户点击 APP 到首页显示，业界有多种不同的阶段划分方式，比较主流的是将其分为三个阶段：</p>
<ul>
<li>main() 函数执行前（pre-main阶段）；</li>
<li>main() 函数执行后；</li>
<li>首页渲染完成之后</li>
</ul>
<h4 id="main-函数启动前">main() 函数启动前</h4>
<p>main() 函数启动前，我们一般称之为 pre-main 阶段，在这个阶段，objc 源码中无法debug，这个过程中主要是 dyld 工作，包括加载可执行文件，符号绑定等等 。</p>
<p>在这里我们先不要仔细拆分整个流程，先从上面的 pre-main 启动时间分析的 log 来看一看这期间主要做了哪些事情：</p>
<ul>
<li>
<p><code>dylib loading</code><br>
加载所有的可执行文件 Mach-O 。</p>
</li>
<li>
<p><code>rebase/binding</code><br>
加载动态链接库 dyld，dyld 递归的加载所有的依赖动态库。并进行 rebase 指针调整和 bind 符号绑定。</p>
</li>
<li>
<p><code>ObjC setup</code><br>
Objc runtime 的初始处理，包括 Objc 相关类的注册、category 注册、selector 唯一性检查等。</p>
</li>
<li>
<p><code>initializer</code><br>
从名字可以看出，这里主要进行初始化。其中包括执行 + load() 方法。 attribute((constructor))  修饰的函数的调用、创建 C++ 静态全局变量。</p>
</li>
</ul>
<h4 id="main-函数之后">main() 函数之后</h4>
<p>这里指的是从 main() 执行开始，到 didFinishLaunchingWithOptions方法中 keyWindow 渲染执行完毕之后。</p>
<p>这里主要是创建全局的 autoreleasepool 和渲染首屏相关的配置文件的读取，渲染的计算等等。</p>
<h4 id="首屏渲染完成后">首屏渲染完成后</h4>
<p>主要包含和非首屏页面渲染不相关的业务，模块的初始化，配置文件的读取等等。<br>
这个阶段用户已经看到页面了，其实不影响首屏的数据时间，但是如果存在线程阻塞，那么还是会影响到用户的体验，还是要注重一下。</p>
<h3 id="优化方向">优化方向</h3>
<p>从启动流程的几个阶段来看，pre-main 和 main() 函数启动之后占的比重比较大，所以大部分关于时间的优化，我们都应该针对这些来做。</p>
<h4 id="pre-main">pre-main</h4>
<ul>
<li>动态库的加载<br>
上面的耗时日志中，我省略了项目中动态库的耗时显示，这里放两个项目中引用的两个动态库的加载时间的 log:</li>
</ul>
<pre><code>CloudyTrace_IOS :  84.64 milliseconds
ZDKDynamicFramework :  15.28 milliseconds 
</code></pre>
<p>可以看到，动态库的耗时还是挺多的，其中 <em>CloudyTrace_IOS</em> 这个动态库的加载时间几乎和一个新建项目的 pre-main 阶段总耗时还多。并且每一个动态库本身也都有依赖关系。<br>
苹果在 wwdc 上也建议少使用动态库，并且尽可能将动态库进行合并，我们在这里可以做的措施有两个：<br>
1、合并动态库，减少动态库的个数，这里推荐一个 grab 开源的一个<a href="https://github.com/grab/cocoapods-pod-merge">工具</a>，可以将多个依赖合并；</p>
<p>2、将依赖转变未静态库，只需要在 <strong>Podfile</strong> 中添加下面代码，但是需要注意的是，它只支持 1.7.x 以上版本</p>
<pre><code class="language-ruby"># Add these in your Podfile (available for CocoaPods v1.7.x+)

target 'YourApp' do
    # all you pods here...
end

pre_install do |installer|
  puts &quot;Make pods linked statically except reserved pods&quot;
  installer.pod_targets.each do |pod|
    if !keep_dynamically_linked.include?(pod.name)
      puts &quot;Override the static_framework? method for #{pod.name}&quot;
      def pod.build_type;
        Pod::Target::BuildType.static_framework
      end
    end
  end
end
</code></pre>
<p>这种方式可能会存在一些问题，比如两个动态库中存在相同命名的文件，这样会引起冲突，并且 github 中也有一些相关的 issues，存在一些开发者再使用过程不起效果的问题。</p>
<ul>
<li>ObjC setup &amp; initializer</li>
</ul>
<p>在这两个过程中，dyld 会将已经加载到内存中的二进制数据交给 runtime 加载为 objc 定义的结构。通过 <code>call_load_methods</code> 遍历所有的类，在遍历期间，通过 <code>call_class_loads</code> 和 <code>call_class_loads</code> 来调用 class 的 <code>+load</code> 方法和 Category 的 <code>+load</code> 方法。这也就说明，类越多，方法越多，则耗时越多。<br>
要特别指出的是在一个 <code>+load</code> 方法里，进行运行时方法替换操作会带来4毫秒的消耗。</p>
<p>关于这个阶段的优化自然对应的就是：</p>
<ul>
<li>删除无用的类和无用的方法，减少类的数目</li>
<li>所以尽量将 <code>+load</code> 方法，替换为 <code>initialize</code>方法。降低<code>+load</code>的执行次数</li>
<li>控制 C++ 全局变量的数量。</li>
</ul>
<h4 id="main-函数调用之后">main() 函数调用之后</h4>
<p>我们经常将第三方库的注册和初始化放在 didFinishLaunchingWithOptions 中，在这个阶段，我们需要的优化点其实就是：<br>
梳理业务，将首屏渲染用不到的业务放到渲染之后去做，将不需要立即初始化和不需要在主线程初始化的，都放在异步进行延时加载。</p>
<p>最后放上第一阶段优化后的 log：</p>
<pre><code>// 苏宁智能的耗时数据
Total pre-main time: 822.32 seconds (100.0%)
         dylib loading time: 210.71 milliseconds (25.6%)
        rebase/binding time:  60.37 milliseconds (7.3%)
            ObjC setup time: 87.20 milliseconds (10.6%)
           initializer time: 464.04 milliseconds (56.4%)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[苏宁智能 iOS 组件化/模块化实践总结]]></title>
        <id>https://blog.wutao.xyz/post/su-ning-zhi-neng-ios-zu-jian-hua-mo-kuai-hua-shi-jian-zong-jie/</id>
        <link href="https://blog.wutao.xyz/post/su-ning-zhi-neng-ios-zu-jian-hua-mo-kuai-hua-shi-jian-zong-jie/">
        </link>
        <updated>2019-06-16T06:23:19.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>&quot;苏宁智能&quot;是一款为智能家居打造的控制平台，有了这款应用，您可以将所有支持的智能家居品牌的设备接入到同一个 App 中，便捷的控制相应设备。</p>
</blockquote>
<p>本文分享苏宁智能 iOS 的组件化/模块化实践过程和自己的心得体会。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>&quot;苏宁智能&quot;是一款为智能家居打造的控制平台，有了这款应用，您可以将所有支持的智能家居品牌的设备接入到同一个 App 中，便捷的控制相应设备。</p>
</blockquote>
<p>本文分享苏宁智能 iOS 的组件化/模块化实践过程和自己的心得体会。</p>
 <!-- more --> 
<h2 id="背景分析">背景分析</h2>
<p>苏宁智能 iOS 端代码从2018.09开始使用 Git 进行管理，代码托管在内网的 GitLab 上。项目的依赖管理工具是CocoaPods，除了 RN 模块为了动态下发进行单独管理外，其他所有的子模块都采用 Pods 库的方式引入。</p>
<h4 id="1-现阶段存在的问题">1、现阶段存在的问题</h4>
<p>在模块化开展之前，苏宁智能主要存在以下几个问题：</p>
<ul>
<li>项目臃肿不堪</li>
</ul>
<p>在组件化 / 模块化之前，苏宁智能 App 的所有代码和资源文件等都是在同一个主工程里的，所以在开发时，每一次都要编译整个项目的所有代码，十分低效，在开发时，大家在各自开发不同的业务时，不仅要时刻和他人同步项目变化、读懂他人代码，还要每次编译完整个项目才能对自己所做的一点修改进行调试，效率低下。</p>
<ul>
<li>团队规模变化和人员变动</li>
</ul>
<p>苏宁智能从2015年开始开发，初始只有一个人开发和维护，后期由于业务发展团队规模迅速扩大，陆续有多个同事加入开发，在我开始参与开发后，已经有10位同事参与开发和维护，大家都在同一个工程上进行业务开发，经常遇到如代码冲突、开发效率低下、职责划分不清、代码管理混乱等问题。<br>
同时由于初期人员变动频繁，缺乏相应的代码规范，导致代码质量参差不齐，也不利于 code review，无法针对性的提高代码质量。</p>
<ul>
<li>业务需求压力</li>
</ul>
<p>由于智能家居业务处在高速发展的阶段，业务增长很快，最直观的表现就是智能硬件产品部不断提出接入多样智能设备的诉求，最后就变成了软件产品展示给我们开发人员的一份接一份的 PRD。紧凑的业务开发需求和各种灵活的功能迫使我们想尽一切能够使用的办法来提高开发效率，提高提测质量。</p>
<ul>
<li>
<p>多项目重用</p>
<p>对于移动开发部来说，苏宁智能并不是仅有的项目，其中还有一些其他单品类的 App， 比如 小Biu音箱App,  小Biu扫地机器人App 等等，对于这些子项目/单品App， 我们希望将苏宁智能App 中的成熟基础组件进行复用，降低开发成本，提交开发效率。</p>
</li>
<li>
<p>插件化开发</p>
<p>对于智能硬件的集成来说，大致分为两类<br>
1、集成后，设备控制通过指令下发，不依赖厂家 SDK；<br>
2、集成后，设备控制通过指令和 SDK 提供的功能进行。<br>
对于后者，往往我们需要针对 SDK 提供的能力进行特性化开发，例如对于智能摄像头，我们需要针对 SDK 方法，将同等于 摄像头App 的功能集成进苏宁智能，然而这些需求往往可以看成一个独立App，和苏宁智能整体业务之间除了用户账户数据外并无其他的联系。<br>
这种情况下，模块化开发本身就是一个强需求。</p>
</li>
</ul>
<h4 id="2-解决方案">2、解决方案</h4>
<p>为了解决以上这些问题，团队曾经进行过如下一些探索：<br>
1、移除无用的第三方库和资源文件，减少打包时间：效果不明显；<br>
2、整理并推动内部 Gitflow 工作流，提高协作效率：有一些效果，但由于项目过大，日常协作仍然吃力；<br>
3、在不拆分主工程的情况下，推动项目整个 Swift 化：由于之前维护项目的前辈离职，导致目前的项目开发人员都对原代码不是十分熟悉，不敢妄加改动，加之业务迭代频繁，开发和测试资源都十分紧张，该工作工作推进十分缓慢。</p>
<p>可以发现上述尝试的结果都不是十分理想，在与 iOS 组内大佬们进行一些沟通，听取大佬们的意见后，决定对原项目进行「组件化 / 模块化拆分」工作，它能带来如下这些好处：</p>
<p>加快编译速度，不用再编译组件 / 模块外没有被依赖到的代码；<br>
便于将每个模块指定给不同负责人进行管理；<br>
降低合并难度，减小冲突和出错概率，提高业务开发效率；<br>
将 Swift 和 OC 代码进行分离，便于进一步 Swift 化工作的推进；<br>
可为模块编写单元测试，提高工作效率，同时方便测试人员进行有针对性的测试。</p>
<h2 id="目标设定">目标设定</h2>
<ul>
<li>功能组件独立：保证所有的底层功能组件从主工程抽出，独立与主工程之外，便于复用、业务模块的调用；</li>
<li>业务模块划分与拆解：将业务按对应用途进行划分和拆解，切断各业务之间的强依赖；</li>
<li>所有组件/模块独立编译：所有功能组件和业务模块能够独立于主工程进行编译，有各自的 Demo 工程；</li>
<li>CocoaPods 发布：在内网 GitLab 进行发布，并且之后对每个模块用 GitFlow 工作流进行管理和后续发布工作。</li>
</ul>
<h2 id="计划">计划</h2>
<p>说到组件化 / 模块化，那么什么是组件化 / 模块化呢？组件化和模块化的区别又在哪里呢？</p>
<p>组件，就是我们对功能的封装，一个功能就是一个组件，数据库、网络、文件操作、社会化分享等等这些功能都是组件。我们之所以要搞出组件的概念，是为了能够让我们的上层业务模块能够随时依赖和调用这些基础功能。组件基本上可以分为基础功能组件、通用 UI 组件、基础业务组件等这几类。所以为了满足上述要求，组件必须具有较高的独立性、扩展性以及复用性。</p>
<p>模块，就是对一系列有内聚性的业务进行整理，将其与其它业务进行切割、拆分，从主工程或原所在位置抽离为一个相对独立的部分。仅仅针对业务而言，比如说我们可以把订单业务独立为为一个模块，可以把个人中心独立为一个模块，把用户登录独立为一个模块等，在 App 中的体现就是一个个独立的 Git 仓库。模块化的一个好处是用到时可以搭积木，比如可以多个工程间复用同一个或几个业务模块，比小Biu音箱，小Biu扫地机器人，除了 UI 界面外它们复用了大量现有的苏宁智能的业务模块代码。</p>
<p>经过小组会议讨论，我们的想法是将共用组件独立出来，然后直接按业务对现有主工程进行拆分大致划分如下表所示：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>库名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础</td>
<td>SNFoundation</td>
<td>基础的 OC 组件，各种零散的、混乱的视图、组件、控件、常量、OC 宏定义等，全放在这里，供上层调用。</td>
</tr>
<tr>
<td>网络</td>
<td>SNNetwork</td>
<td>网络组件，对 AFNetworking 的浅层封装，同时包含了和网络相关的业务功能。</td>
</tr>
<tr>
<td>数据库</td>
<td>SNDatabase</td>
<td>数据库组件，对 FMDB 的浅层封装</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>模块</th>
<th>库名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>登录</td>
<td>SNLoginModule</td>
<td>登录模块，包含和登录、注册页面相关的资源文件、UI、业务逻辑代码等。</td>
</tr>
<tr>
<td>用户中心</td>
<td>SNUserCenterModule</td>
<td>用户中心模块，包含和用户个人中心以及状态相关的资源文件、UI、业务逻辑代码等。</td>
</tr>
<tr>
<td>场景</td>
<td>SNScene</td>
<td>场景模块，包含场景相关的资源文件，UI，业务逻辑代码</td>
</tr>
<tr>
<td>极物摄像头</td>
<td>SNWJACamera</td>
<td>极物摄像头设备模块，包含极物摄像头相关的资源文件，UI，业务逻辑代码</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>因为团队开发人员之前均没有过任何项目的拆分经验，大家也都是摸着石头过河，走一步看一步。所以虽然以上的拆分思路总体是对的，先拆组件后拆业务，但由于各种各样的原因，一些问题就在接下来的工作实施过程中暴露了出来。</p>
<h2 id="实施">实施</h2>
<p>由于团队主要还是以业务开发为主，所以组件化 / 模块化工作都是大家抽空闲时间来完成，并没有进行硬性的排期。所以按照之前制定的计划，我们进行了以下这些工作：</p>
<h4 id="功能组件独立">功能组件独立</h4>
<p>因为我们在进行拆分任务的同时，还在同时维持着项目的开发工作，所以我们只是初步大致的对功能点进行了一些划分<br>
例如 SNFoundation<br>
SNFoundation 是我们项目最先抽出的部分，这个库作为整个工程的最底层，其中大致包含以下一些东西：</p>
<ul>
<li>自定义的 View 和控件，例如：小红点控件、刷新控件、加载控件、Tips 视图等；</li>
<li>自定义的 Controller，例如：基础控制器 BaseViewController、WebView 基础控制器 BaseWebViewController、自定义的弹框 AlertController等；</li>
<li>业务相关的对基本类型或系统控件的扩展：对 NSObject、UIButton、UIImageView、UILabel 等添加的扩展代码 category；<br>
因为我们在进行拆分任务的同时，还在同时维持着项目的开发工作，所以我们暂时没有精力做细致的拆分工作，只能先把这些零散的部分先放在一起进行管理。</li>
</ul>
<h4 id="业务模块的划分">业务模块的划分</h4>
<p>完成了上面的组件库的独立工作后，业务模块的拆解就相对轻松一些了，目前我们已经完成了多个业务模块的拆分工作。<br>
主要分为两个种类：<br>
一个是主体业务逻辑相关，比如 SNLoginModule， SNSceneModule：</p>
<ul>
<li>SNLoginModule<br>
SNLoginModule 用户登录模块是一个与用户登录、注册以及用户登录信息有关的模块，主要包含了以下内容：<br>
UI，例如：用户登录界面、用户注册界面等；<br>
数据模型，例如：用户信息模型、用户信息地址模型等；<br>
登录与注册相关的网络请求。<br>
主要依赖了 SNFoundation、SNNetwork 组件。</li>
</ul>
<p>另一个是设备相关， 比如 SNWJACamera, SNProscenicRobot:</p>
<ul>
<li>SNWJACamera<br>
SNWJACamera 极物摄像头模块，顾名思义是极物单品类摄像头相关的模块，主要包含了下面内容：<br>
UI，例如：实时直播页面，云台控制页面、录像回放页面，设备设置页面等；<br>
数据模型，例如：录像模型、回放模型、控制指令模型等；<br>
与三方 Pass 交互相关的网络请求。<br>
主要依赖了 SNFoundation、SNNetwork 组件。</li>
</ul>
<h4 id="解耦合方案">解耦合方案</h4>
<p>对于模块之间的调用和解除耦合方面，由于已经2019年了，大多数的路由方案都已经很成熟了，我们在评估了常用的几个开源方案之后，引入了阿里的开源库 <a href="https://github.com/alibaba/BeeHive/blob/master/README-CN.md">BeeHive</a>来作为模块化之间调用和解耦的方案。<br>
项目中的模块间调用如下图所示：<br>
<img src="https://camo.githubusercontent.com/686d58ea786e73b5a7562267e25720c922605db6/687474703a2f2f67746d7330322e616c6963646e2e636f6d2f7470732f69322f54423164687946494658585858617661585858376a6a62534658582d3531352d3233332e6a70675f343030783430302e6a7067" alt="" loading="lazy"></p>
<h2 id="总结">总结</h2>
<p>由于团队成员均没有组件化/模块化经验，所以在整个过程中出现了一些问题：</p>
<ol>
<li>
<p>不合理的分层结构和库间依赖<br>
由于参与拆分工作的人员比较缺乏组件化经验，所以导致某些库的拆分不是十分合理，某些应该沉入底层的公用 Model 和常量等没有在开始时就放到一个合理的位置。业务模块之间也存在一些不合理的横向依赖，没有进行一个合理的业务边界划分。这些原因导致我们在进行拆分工作时经常需要回过头来对已经拆出来的模块和组件重新进行整理和处理，重复劳动量很大。</p>
</li>
<li>
<p>拆分粒度不适中<br>
某些库比如 SNFoundation 比较庞大，其中既存在 category， 也有自定义的 View，整体比较臃肿。如果一个拆分完成的库仍然比较臃肿的化，说明仍然存在细化拆分的必余地。</p>
</li>
<li>
<p>工作进度难以控制<br>
由于没有能提前制定好详细的进度计划表，加上业务工作的挤压，导致我们花在组件化 / 模块化工作上的时间比较零散。本意是希望大家能够灵活安排工作，合理处置业务开发与技术改造工作之间的关系，但效果不是很理想，表现就是组件化 / 模块化工作的进行没有连续性，大家的积极性和工作效率也都不高。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何创建一个 Xcode server Bot （自动打包机器人）]]></title>
        <id>https://blog.wutao.xyz/post/ru-he-chuang-jian-yi-ge-xcode-server-bot-zi-dong-da-bao-ji-qi-ren/</id>
        <link href="https://blog.wutao.xyz/post/ru-he-chuang-jian-yi-ge-xcode-server-bot-zi-dong-da-bao-ji-qi-ren/">
        </link>
        <updated>2019-06-15T06:47:28.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="如何创建一个-xcode-server-bot-自动打包机器人">如何创建一个 Xcode server Bot （自动打包机器人）</h1>
<p>本文是一份教学文档，对于有单独打包机的开发团队有效。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="如何创建一个-xcode-server-bot-自动打包机器人">如何创建一个 Xcode server Bot （自动打包机器人）</h1>
<p>本文是一份教学文档，对于有单独打包机的开发团队有效。</p>
<!-- more -->
<h2 id="概述">概述</h2>
<p>为了解决平时生产过程中打包流程繁琐，打包分散，不同开发人员打包配置不同导致的包功能不全等问题。经过研究几种自动化打包方法，现决定使用苹果未开发人员提供的自动化打包方案，Xcode server 解决上述问题。</p>
<h2 id="xcode-server-是什么">Xcode server 是什么？</h2>
<p>Xcode Server，苹果提供了一个自带的 CI 方案，可以理解为 Jenkins 和 fastlane 的功能集合体，是一个持续化集成和打包测试工具。具体描述和功能，请自行百度/ google。</p>
<h2 id="配置方法">配置方法</h2>
<p>首先连接内网，原因是，版本管理是基于内网的 gitlab，而 Xcode server 依赖于 git 服务。</p>
<p>然后打开 Xcode 选择左边功能栏的标识处</p>
<figure data-type="image" tabindex="1"><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g3ci8tchnpj30b5026aau.jpg" alt="" loading="lazy"></figure>
<p>然后选择 SmartHome 的 Mac mini （Xcode server 服务提供机器）<br>
这里是因为之前的配置已经完成，我直接省略了部署 Xcode server 步骤，有兴趣请自行了解😂</p>
<figure data-type="image" tabindex="2"><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g3cibgx6a2j309o08nwi8.jpg" alt="" loading="lazy"></figure>
<p>然后选择 Create Bot</p>
<figure data-type="image" tabindex="3"><img src="https://ws4.sinaimg.cn/large/006tNc79gy1g3cicw8rbnj309w0dvahp.jpg" alt="" loading="lazy"></figure>
<p>第一步  输入 Bot 名字和部署 Xcode server 服务的机器（名字建议和版本分支关联，尽量详细一些）</p>
<figure data-type="image" tabindex="4"><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g3cinqgrfnj30kc0c0gnh.jpg" alt="" loading="lazy"></figure>
<p>第二步 验证 git 服务的账号密码</p>
<figure data-type="image" tabindex="5"><img src="https://ws4.sinaimg.cn/large/006tNc79gy1g3cioreubsj30kd0c040m.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://ws4.sinaimg.cn/large/006tNc79gy1g3cioreubsj30kd0c040m.jpg" alt="" loading="lazy"></figure>
<p>第三步 选择想要自动打包的分支</p>
<figure data-type="image" tabindex="7"><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g3cipqvncij30kc0c343b.jpg" alt="" loading="lazy"></figure>
<p>第四步 选择导出方式，这里选择自定义导出</p>
<figure data-type="image" tabindex="8"><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g3cir7u4jsj30kg0c0418.jpg" alt="" loading="lazy"></figure>
<p>自定义导出需要一个 exportoption plist， 这个主要是告诉 server 本次打包的一些配置，例如打包方式，描述文件和证书配置之类的设定，<br>
获取方式：手动导出一个 ipa 可以获取。</p>
<figure data-type="image" tabindex="9"><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g3ciu0z7h9j30m70bmjso.jpg" alt="" loading="lazy"></figure>
<p>第五步 选择打包频率<br>
主要有三个选择，周期性，手动和检测到 commit<br>
简单解释一下， 周期性顾名思义，可以设定在每天或者每个小时，或者每周打包；<br>
手动就是，每次有需要时，由开发人员手动开启打包；<br>
Commit 是每次检测到 当前集成分支有 commit 时，自动开启打包流程。<br>
本次我们选择 <strong>周期性打包</strong>， 在每天的 9点，14点和 19点进行打包。</p>
<figure data-type="image" tabindex="10"><img src="https://ws4.sinaimg.cn/large/006tNc79gy1g3ciup6uv0j30kc0c0q67.jpg" alt="" loading="lazy"></figure>
<p>第五步 选择为指定设备打包<br>
可以选择仅为真实设备打包，或者为真实设备和模拟器一起打包，这里我们选择为真实设备打包（其实都可以😜）<br>
<img src="https://ws2.sinaimg.cn/large/006tNc79gy1g3cj03o1mwj30ke0bz778.jpg" alt="" loading="lazy"></p>
<p>第六步， 第七步 可以跳过，不需配置</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g3cj2tyi5uj30kf0c2tax.jpg" alt="" loading="lazy"><br>
<img src="https://ws4.sinaimg.cn/large/006tNc79gy1g3cj3isgw3j30ke0c0taw.jpg" alt="" loading="lazy"></p>
<p>第八步  添加脚本<br>
这个配置主要用来做一些额外操作，比如在打包前，我们可能需要更新下 pod，那么我们可以选择 Pre-integration 添加操作脚本，基于 bash；</p>
<figure data-type="image" tabindex="11"><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g3cj3rkjabj30kh0c6q5n.jpg" alt="" loading="lazy"></figure>
<p>在本 Bot 中，我们需要打包完成后，自动将导出的 ipa 上传到内网 ipa 仓库；<br>
所以选择 Post-integration，并添加以下脚本：</p>
<pre><code class="language-bash">
# 打印 ipa 路径 
echo $XCS_PRODUCT

# 苏宁智能 appId
appId=&quot;8&quot;

# 苏宁智能 versionId
versionId=&quot;542&quot;

# ipa 上传路径
uploadUrl=&quot;xxxxxxx/upload.json&quot;

# ipa 名称
ipa_Name=&quot;Smarthome&quot;

# ipa bundle_id
bundle_id=&quot;com.suning.intelligence&quot;

# 上传包到 ipa
curl -F &quot;appId=${appId}&quot; -F &quot;versionId=${versionId}&quot; -F &quot;bundleId=${bundle_id}&quot; -F &quot;ipaDesc=${ipaName}&quot; -F &quot;ipaFile=@$XCS_PRODUCT&quot; ${uploadUrl}


</code></pre>
<figure data-type="image" tabindex="12"><img src="https://ws4.sinaimg.cn/large/006tNc79gy1g3cj8pu2r8j30kd0cr0vo.jpg" alt="" loading="lazy"></figure>
<p>最终点击 Done 完成，配置完成后，会进行初次打包，可能会有各种检测，因此时间较长，大约 30min，除此之外，平均打包时间在 11min 之内（当然了，看配置）。</p>
<h2 id="注意事项">注意事项</h2>
<p>1、由于每次打包，Server 都会从集成分支拉去最新代码，所以我们需要保证提交代码时 bundleid 和证书配置需要为 release 配置</p>
<figure data-type="image" tabindex="13"><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g3cjdb6bwlj30zm0kltbs.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js + MongoDB + Nginx 线上部署]]></title>
        <id>https://blog.wutao.xyz/post/nodejs-mongodb-nginx-xian-shang-bu-shu/</id>
        <link href="https://blog.wutao.xyz/post/nodejs-mongodb-nginx-xian-shang-bu-shu/">
        </link>
        <updated>2018-09-17T06:53:10.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="nodejs-mongodb-nginx-线上部署">Node.js + MongoDB + Nginx 线上部署</h1>
<p>Linux 版本为 centos7</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="nodejs-mongodb-nginx-线上部署">Node.js + MongoDB + Nginx 线上部署</h1>
<p>Linux 版本为 centos7</p>
 <!-- more --> 
<h2 id="安装-nodejs">安装 node.js</h2>
<p>首先直接使用 yum 安装</p>
<pre><code>$	yum -y install nodejs
</code></pre>
<p>但是此时并不是最新的版本， 应该是6.xxx，可以使用 <code>node -v</code> 查看；</p>
<h4 id="升级到最新版本">升级到最新版本</h4>
<p>首先安装 <strong>n</strong>(nodejs 管理工具)</p>
<pre><code>$ npm install -g n
</code></pre>
<p>安装完成后安装 node.js 最新版本</p>
<pre><code>$ n latest
</code></pre>
<p>然后使用</p>
<pre><code>$ n
</code></pre>
<p>选择最新版本。</p>
<h2 id="安装-mongodb">安装 MongoDB</h2>
<p>首先编写 yum 库文件</p>
<pre><code>$  sudo vi /etc/yum.repos.d/mongodb-org.repo
</code></pre>
<p>将下面文本写入</p>
<pre><code>[mongodb-org-3.4]
name=MongoDB Repository
baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/
gpgcheck=1
enabled=1
gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc
</code></pre>
<p>保存并退出；<br>
检查可用库：</p>
<pre><code>$  yum repolist
</code></pre>
<p>如果看到</p>
<pre><code>. . .
repo id                          repo name
mongodb-org-3.2/7/x86_64         MongoDB Repository
. . .
</code></pre>
<p>就可以进行安装操作</p>
<pre><code>$  sudo yum install mongodb-org
</code></pre>
<p>安装结束后，启动它</p>
<pre><code>$  sudo systemctl start mongod
</code></pre>
<p>如果需要在外部连接 MongoDB, 还需要将 bindIp 由 <strong>127.0.0.1</strong> 切换为 <strong>0.0.0.0</strong></p>
<pre><code>vi /etc/mongod.conf

# network interfaces
net:
  port: 27017
  bindIp: 0.0.0.0  # Listen to local interface only, comment to listen on all interfaces.
</code></pre>
<h2 id="安装-nginx">安装 Nginx</h2>
<p>前期准备</p>
<pre><code>$  yum install gcc-c++
$  yum -y install zlib zlib-devel openssl openssl--devel pcre pcre-devel
</code></pre>
<p>安装结束后，执行安装 Nginx 的命令：</p>
<pre><code>$  yum install nginx -y
</code></pre>
<h4 id="反向代理配置">反向代理配置</h4>
<p>进入 nginx 文件夹</p>
<pre><code>$  cd /etc/nginx
</code></pre>
<p>打开配置文件：</p>
<pre><code>$  vim nginx.conf
</code></pre>
<p>忽略其他，我们看 server， 删除多余的，将 server 改造成下面这样：</p>
<pre><code>    server {
        listen       80;
        server_name  _;
        root         /usr/share/nginx/html;

        # Load configuration files for the default server block.
        include /etc/nginx/default.d/*.conf;

        location / {
        }

        error_page 404 /404.html;
            location = /40x.html {
        }

        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }

</code></pre>
<p>然后我们新增自己的代理配置,类似于下面：</p>
<pre><code>    server {
        listen 80;
        server_name xxx.com www.xxx.top;
        location / {
                proxy_pass http://127.0.0.1:8080;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header Host $http_host;
                proxy_set_header X-Nginx-Proxy true;
                proxy_redirect off;
        }
    }

</code></pre>
<p>解释下：</p>
<ul>
<li>server_nme 是域名，这边可以配置一级或者二级域名；</li>
<li>proxy_pass 是ip，通常直接以 127.0.0.1 代替，当然你也可以写你云服务器的公网ip；</li>
</ul>
<p>其他的照着写就👌， 上面文本达成的效果是，使用 server_name 代替直接访问 ip.<br>
Ps. server_name 只能填写域名解析后的域名，并且需要在云服务器安全组中添加 80 端口的支持规则。</p>
<h4 id="ssl-配置">SSL 配置</h4>
<p>首先要申请证书，并且下载到本地。<br>
通常它们会是这样命名：</p>
<pre><code>// xxx 是域名
cert-1541562634350_xxx.crt
cert-1541562634350_xxx.key
</code></pre>
<p>下载完后，使用 FTP 等同类工具上传到云服务器上，在 <strong>/etc/nginx</strong> 文件夹下创建 <strong>cert</strong>,将这这两个文件移到这个文件夹下；</p>
<p>接着编写  nginx.conf</p>
<pre><code>    server {
        listen       443 ssl;
        server_name  *.xxx.com;
        root         /usr/share/nginx/html;

        ssl_certificate /etc/nginx/cert/cert-1541562634350_www.funnyfm.top.crt;
        ssl_certificate_key /etc/nginx/cert/cert-1541562634350_www.funnyfm.top.key;
        ssl_session_cache shared:SSL:1m;
        ssl_session_timeout  10m;
        ssl_ciphers HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers on;

        location / {
                proxy_pass http://127.0.0.1:8080;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header Host $http_host;
        }

        error_page 404 /404.html;
            location = /40x.html {
        }
        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }
</code></pre>
<p>几个注意点：</p>
<ul>
<li>SSL 监听的是 443 端口，需要在安全规则中添加；</li>
<li>每一个 SSL server 需要对应一个 http 80 的server</li>
</ul>
<p>编写结束后，需要重启 Nginx</p>
<pre><code>$  nginx -s reload
</code></pre>
<p>好了，现在可以使用 <code>xxx.com</code> 来代替直接访问 ip 了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从 objc_msgSend 开始探究方法执行的全部流程]]></title>
        <id>https://blog.wutao.xyz/post/cong-objc_msgsend-lai-liao-liao-runtime/</id>
        <link href="https://blog.wutao.xyz/post/cong-objc_msgsend-lai-liao-liao-runtime/">
        </link>
        <updated>2018-07-08T08:47:23.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>以下对源码的分析都基于 objc4-750 版本</p>
</blockquote>
<h2 id="前言">前言</h2>
<p>本文将从 <code>objc_msgSend</code> 开始一步步的探究方法执行的全部流程。</p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>以下对源码的分析都基于 objc4-750 版本</p>
</blockquote>
<h2 id="前言">前言</h2>
<p>本文将从 <code>objc_msgSend</code> 开始一步步的探究方法执行的全部流程。</p>
<!-- more --> 
<p>对于 iOS 开发者来说，<strong>runtime</strong> 是一个无法避免的，需要深入了解的一个知识点。但是源码的复杂，文件数目的繁多对于我们理解它并不友好，找到一个好的切入点就尤为重要。</p>
<h2 id="消息机制">消息机制</h2>
<p>objc_msgSend 函数是所有 OC 方法调用的核心引擎，它负责查找真实的类或者对象方法的实现，并去执行这些方法函数，底层由汇编语言编写。</p>
<pre><code class="language-c">objc_msgSend(id _Nullable self, SEL _Nonnull op, ...)
</code></pre>
<p>这个方法接受多个参数， 第一个参数是消息的接受者，第二个参数是 <code>SEL</code>， 后面不定数目的参数是 <code>SEL</code> 所需的参数。<br>
那么 <code>objc_msgSend</code> 的执行流程是什么C呢？它又涉及到哪些方法呢？</p>
<h2 id="执行流程">执行流程</h2>
<p><code>objc_msgSend()</code> 的执行流程可以分为 3 大阶段：</p>
<ul>
<li>消息发送（方法查找）</li>
<li>动态方法解析</li>
<li>消息转发<br>
这三个流程并不总会同时发生；<br>
<em>动态方法解析</em> 取决于 <em>消息发送</em> 的结果；<br>
<em>消息转发</em> 取决于 <em>动态解析的结果</em>；</li>
</ul>
<h3 id="消息发送方法查找">消息发送（方法查找）</h3>
<p>先来看看 <strong>消息发送</strong> 的流程：</p>
<ul>
<li>
<p>第一步<br>
<code>objc_msgSend</code> 首先会判断第一个参数，也就是消息的 receiver (接受对象)，如果 receiver 为 nil，那么直接退出流程；如果不为 nil 接着下一步；</p>
</li>
<li>
<p>第二步<br>
如果 receiver 不为 nil， 去 receiver 的 class 的 cache 中查找方法，如果找到，那么执行方法，如果找不到，接着下一步；</p>
</li>
<li>
<p>第三步<br>
在 receiver.class 的 cache 中未找到方法，那么将去类的 class_rw_t 中查找方法，如果找到，那么执行方法，并将方法保存到 cache 中；如果未找到，接着下一步；</p>
</li>
<li>
<p>第四步<br>
如果在 class_rw_t 中未找到方法，那么会从 superclass 的 cache 中查找方法，如果查找到，那么执行方法，并且存储到 receiver.class 的 cache 中；如果未查找到，接着下一步；</p>
</li>
<li>
<p>第五步<br>
如果在 superclass 的 cache 中未找到，那么会从 superclass 的 class_rw_t 中查找方法，如果查找到，那么执行方法，并且存储到 receiver.class 的 cache 中；如果未查找到，接着下一步；</p>
</li>
<li>
<p>第六步<br>
如果在 receiver.class 的 superclass 中未查找到方法，那么会判断 superclass 是否有 superclass，如果有，那么会重复第四步和第五步； 如果没有，那么会进入动态方法解析流程。</p>
</li>
</ul>
<p>以上就是<strong>消息发送</strong>的全部流程。那么我们通过这个流程，看看其中涉及的一些相关知识。</p>
<p>首先 receiver , receiverClass , receiverClass.superclass 之间的相关联系，receiver 的方法是存储在什么地方的 ？<br>
首先上一张经典图：</p>
<figure data-type="image" tabindex="1"><img src="http://blog.leichunfeng.com/images/object_model.png" alt="" loading="lazy"></figure>
<p>这张图是苹果官方对类的解释，每个实例（instance）都有自己的类（class），每个类也有自己的元类（meta-class）；实例，类，元类都有 isa 指针，实例的 isa 指针，指向类，类的 isa 指针指向元类，元类的 isa 指针指向基类的元类，基类的元类的指针指向自己。</p>
<p>我们在看一下，OC 中对象的数据结构：</p>
<pre><code class="language-C">struct objc_class : objc_object {
    // Class ISA;
    Class superclass;         
    cache_t cache;             // 方法缓存
    class_data_bits_t bits;    // 用于获取具体的类信息 

    class_rw_t *data() { 
        return bits.data();
    }
};

struct class_data_bits_t {
    uintptr_t bits;
public:
    class_rw_t* data() {
        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);
    }
};

// 类相关读写信息
struct class_rw_t {
    // Be warned that Symbolication knows the layout of this structure.
    uint32_t flags;
    uint32_t version;

    const class_ro_t *ro;

    method_array_t methods;       // 方法列表
    property_array_t properties;  // 属性列表
    protocol_array_t protocols;   // 协议列表

    Class firstSubclass;
    Class nextSiblingClass;

    char *demangledName;
};

// 类相关的只读信息，只保存了初始内容
struct class_ro_t {
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;  // instance对象占用的内存空间
#ifdef __LP64__
    uint32_t reserved;
#endif
    const uint8_t * ivarLayout;    
    const char * name;  
    method_list_t * baseMethodList;  
    protocol_list_t * baseProtocols;
    const ivar_list_t * ivars; 
    const uint8_t * weakIvarLayout;
    property_list_t *baseProperties;
    method_list_t *baseMethods() const {
        return baseMethodList;
    }
};
</code></pre>
<p>通过上述代码和其中的一些解释，我们不难发现他们之间的联系，这里再解释一下 <code>class_ro_t</code> 和 <code>class_rw_t</code> 之间的关系。<br>
<code>class_ro_t</code> 存储了初始的内容，是只读的，不可改。runtime 初始化时在 <code>realizeClass()</code> 函数中将其中的内容和分类中的内容合并起来放入 <code>class_rw_t</code> 中，并将 class 的 bits 指向 <code>class_rw_t</code>。</p>
<h3 id="动态方法解析">动态方法解析</h3>
<p>这一步是运行时的第一个对无法找到的方法的挽救措施，如果动态解析成功，那么会从 <strong>消息发送</strong>流程的第二步开始重新走发送流程，如果没有成功，那么将会进行下一步<strong>消息转发</strong>流程。<br>
<strong>动态方法解析</strong>有下面几步：</p>
<ul>
<li>第一步<br>
根据方法的类型（实例方法还是类方法）runtime 会调用：<pre><code class="language-C">+(BOOL)resolveInstanceMethod:(SEL)sel
+(BOOL)resolveClassMethod:(SEL)sel
</code></pre>
</li>
</ul>
<p>重写上述代码，动态添加方法的实现：</p>
<pre><code>BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)
</code></pre>
<h3 id="动态消息转发">动态消息转发</h3>
<p>如果“消息发送”阶段未找到方法的实现，且通过<strong>动态方法解析</strong>没有解决， 就进入<strong>消息转发</strong>阶段，<strong>消息转发</strong>阶段分两步进行：Fast forwarding 和 Normal forwarding。</p>
<p><strong>Fast forwarding</strong><br>
将消息转发给一个其它 OC 对象（找一个备用接收者）， 我们可以重写以下方法，返回一个非 receiver 的对象，来完成这一步骤：</p>
<pre><code class="language-c">+/- (id)forwardingTargetForSelector:(SEL)sel;
</code></pre>
<p><strong>Normal forwarding</strong><br>
通过实现一个完整的消息转发过程， 如果上一步没能解决未知消息，可以重写以下两个方法启动完整的消息转发：<br>
第一个方法：我们需要在该方法中返回一个适合该未知消息的方法签名（方法签名就是对返回值类型、参数类型的描述，可以使用 Type Encodings 编码，</p>
<pre><code class="language-c">+/- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
// Runtime 会根据这个方法签名，创建一个NSInvocation对象（NSInvocation封装了未知消息的全部内容，包括：方法调用者 target、方法名 selector、方法参数 argument 等），然后调用第二个方法并将该NSInvocation对象作为参数传入。
</code></pre>
<p>第二个方法：我们可以在该方法中, 将未知消息转发给其它对象；改变未知消息的内容(如方法名、方法参数)再转发给其它对象；甚至可以定义任何逻辑。</p>
<pre><code class="language-c">+/- (void)forwardInvocation:(NSInvocation *)invocation
</code></pre>
<p>如果第一个方法中没有返回方法签名，或者我们没有重写第二个方法，系统就会认为我们彻底不想处理这个消息了，这时候就会调用<code>+/- (void)doesNotRecognizeSelector:(SEL)sel</code>方法并抛出经典的 <code>crash:unrecognized selector sent to instance/class</code>，结束 objc_msgSend 的全部流程。</p>
<pre><code>+ (id)forwardingTargetForSelector:(SEL)sel {
    return nil;
}
+ (NSMethodSignature *)methodSignatureForSelector:(SEL)sel {
    _objc_fatal(&quot;+[NSObject methodSignatureForSelector:] &quot;
                &quot;not available without CoreFoundation&quot;);
}
+ (void)forwardInvocation:(NSInvocation *)invocation {
    [self doesNotRecognizeSelector:(invocation ? [invocation selector] : 0)];
}
+ (void)doesNotRecognizeSelector:(SEL)sel {
    _objc_fatal(&quot;+[%s %s]: unrecognized selector sent to instance %p&quot;, 
                class_getName(self), sel_getName(sel), self);
}
</code></pre>
<h2 id="总结">总结</h2>
<p>以上就是 <code>runtime</code> 中关于消息发送的所有流程。<br>
深入了解这些流程和细节后，我们可以用它实现很多有意思的事情。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[探究 Runloop 底层结构 ]]></title>
        <id>https://blog.wutao.xyz/post/tan-jiu-runloop/</id>
        <link href="https://blog.wutao.xyz/post/tan-jiu-runloop/">
        </link>
        <updated>2018-06-17T06:54:29.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="探究-runloop">探究 Runloop</h1>
<blockquote>
<p>对于 iOS 开发者来说， Runloop 应该是大家都熟悉的，这篇文章只是本人在阅读源码时的一些理解。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h1 id="探究-runloop">探究 Runloop</h1>
<blockquote>
<p>对于 iOS 开发者来说， Runloop 应该是大家都熟悉的，这篇文章只是本人在阅读源码时的一些理解。</p>
</blockquote>
<!-- more --> 
<h3 id="runloop-相关结构体">Runloop 相关结构体</h3>
<p>Objective-C 是对 C 的封装，所以一切相关的底层其实都是通过 C 来实现的，我们先看下 Runloop 相关的概念。<br>
这里说的 Runloop 并不是 Apple 在 iOS 中的实现，因为 iOS 不是开源的。我们现在所说的其实只是 Apple 开源的 CF 框架的源码，但是管中窥豹，通过它也能了解 Apple 的思路。</p>
<h4 id="__cfrunloop">__CFRunLoop</h4>
<p>首先是 Runloop，底层是 C 的结构体</p>
<pre><code class="language-C">struct __CFRunLoop {
    __CFPort _wakeUpPort;			// used for CFRunLoopWakeUp 
    volatile _per_run_data *_perRunData;   // 预设状态
    pthread_t _pthread; // 线程
    CFMutableSetRef _commonModes; // 存储 ModeName
    CFMutableSetRef _commonModeItems; 
    CFRunLoopModeRef _currentMode; // 当前 Mode
    CFMutableSetRef _modes;  // 所有的 Mode
    ...
};
</code></pre>
<p>上面列出的是相对重要的部分， 我们一个一个看。没有细说的注意看代码块中的注释<br>
首先 <strong>_wakeUpPort</strong> 这是用来进行唤醒 Runloop 的特定端口；<br>
然后是 <strong>_perRunData</strong> 这个需要结合下面代码来看：</p>
<pre><code class="language-C">// 是否是 停止状态
CF_INLINE Boolean __CFRunLoopIsStopped(CFRunLoopRef rl) {
    return (rl-&gt;_perRunData-&gt;stopped) ? true : false;
}

// 标记为停止状态
CF_INLINE void __CFRunLoopSetStopped(CFRunLoopRef rl) {
    rl-&gt;_perRunData-&gt;stopped = 0x53544F50;	// 'STOP'
}

...

</code></pre>
<p>可以看到，runloop 的很多状态都是存储在 <strong>_perRunData</strong> 之中的，我们可以把它看做是 runloop 的状态指示器。</p>
<p><strong>_pthread</strong> 的类型是 <strong>pthread_t</strong> ，这是 pthread 的底层，这样也说明了，为什么线程和 <strong>runloop</strong> 是一一对应的；</p>
<p><strong>_commonModes</strong> 这是一个集合， 主要存储着 modename；</p>
<p><strong>_commonModeItems</strong> 也是一个集合， 主要存储着 modename 对应的 <strong>CFRunLoopModeRef</strong> 中的 Source/Observer/Timer；</p>
<h4 id="cfrunloopmoderef">CFRunLoopModeRef</h4>
<p>通过 Runloop 的结构体，我们可以看到，<strong>CFRunLoopModeRef</strong> 在其中占据很大的比例，那么我们继续看 <strong>CFRunLoopModeRef</strong> 是什么东西：</p>
<pre><code class="language-C">struct __CFRunLoopMode {
    CFStringRef _name;
    CFMutableSetRef _sources0;
    CFMutableSetRef _sources1;
    CFMutableArrayRef _observers;
    CFMutableArrayRef _timers;
    ...
};
</code></pre>
<p>很长一段，我只贴出来一部分，其他可以看源码。可以看到也是一个结构体（其实所有OC类的底层实现都是C中的结构体）。</p>
<p>在这其中，其实就是三类成员，<strong>__CFRunLoopSource</strong>， <strong>__CFRunLoopObserver</strong> 和 <strong>__CFRunLoopTimer</strong>。</p>
<p>它们的关系可以看这幅图，比较直观：<br>
<img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png" alt="" loading="lazy"></p>
<p>那么继续，我们在聊聊这三个家伙是个啥。</p>
<h4 id="__cfrunloopsource">__CFRunLoopSource</h4>
<p>Mode 结构体中 source 有两个版本，一个source0，一个source1。<br>
先说下，source 是什么，runloop 中，需要一个标识来告诉它，是否有事件需要处理，然而单纯的使用一个标识符无法实现比较复杂的需求，这时候 source 就出现了，通过调用方法，来得到一个 BOOL 值，通过这个值来确定是否需要处理事件。</p>
<p>为什么这么说？我们需要看下这个方法：</p>
<pre><code>	static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode){
			...
			Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);
	    if (sourceHandledThisLoop) {
            __CFRunLoopDoBlocks(rl, rlm);
	    }
			...
			
			sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;
	    sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;
			...
	
	}
	
</code></pre>
<p>这是 Runloop 启动方法，后面会仔细分析，现在主要看贴出来的方法。</p>
<p>可以看到，runloop 处理事件主要是通过三个方法：<br>
<strong>__CFRunLoopDoSources0</strong> ， <strong>__CFRunLoopDoSource1</strong> 和 <strong>__CFRunLoopDoBlocks</strong>。</p>
<p>前两个是用来标志是否存在需要处理的事件，如果存在，则调用第三个方法，处理事件。</p>
<p>Source 也分为2个版本 Source0 和 Source1。</p>
<p>• <strong>Source0</strong> 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</p>
<p>• <strong>Source1</strong> 包含了一个 mach_port 和一个回调（函数指针），这种 Source 能主动唤醒 RunLoop 的线程。</p>
<h4 id="cfrunlooptimerref">CFRunLoopTimerRef</h4>
<p><strong>CFRunLoopTimerRef</strong> 就很好理解了，它实际上是和 NSTimer 是同一个东西，也就是说，它就是一个定时器。这里简单介绍一下，后面计划有一篇关于 <strong>NSTimer</strong> 的文章。</p>
<pre><code class="language-C">
struct __CFRunLoopTimer {
    CFRunLoopRef _runLoop;
    CFMutableSetRef _rlModes;
    CFTimeInterval _interval;		/* immutable */
    CFTimeInterval _tolerance;          /* mutable */
    CFAbsoluteTime _nextFireDate;
    CFIndex _order;			/* immutable */
    CFRunLoopTimerCallBack _callout;	/* immutable */
    ...
};

</code></pre>
<p>看上面的结构， <strong>__CFRunLoopTimer</strong> 主要包含下列相关：</p>
<p><strong>_runLoop</strong>：NSTimer 必须和 runloop 配合使用，那么 timer 持有 runloop 是可以理解咯；<br>
<strong>_interval</strong>： 间隔时间；<br>
<strong>_tolerance</strong>： 容忍时间，也就是说允许延迟多长时间；<br>
<strong>_nextFireDate</strong>：下次触发时间，理论上应该每次累加 _interval ，但是由于容忍度的存在，并不能两次相隔时间并不一定和 _interval 相等；<br>
<strong>_order</strong>： 优先级；<br>
<strong>_callout</strong>：timer 关联的回调事件；</p>
<h4 id="__cfrunloopobserver">__CFRunLoopObserver</h4>
<pre><code class="language-C">    struct __CFRunLoopObserver {
    CFRunLoopRef _runLoop;
    CFIndex _rlCount;
    CFOptionFlags _activities;		/* immutable */
    CFIndex _order;			/* immutable */
    CFRunLoopObserverCallBack _callout;	/* immutable */
};
</code></pre>
<p><strong>__CFRunLoopObserver</strong> 中除了常规的几个成员外， 比较重要的应该就是 <strong>_activities</strong> ， 它标识了 runloop 的状态，主要包括</p>
<pre><code class="language-C">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry = (1UL &lt;&lt; 0),               // 即将进入 Loop
    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),        // 即将处理 Timers
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),       // 即将处理 Sources
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),       // 即将进入休眠
    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),        // 刚从休眠中唤醒
    kCFRunLoopExit = (1UL &lt;&lt; 7),                // 即将退出Loop
    kCFRunLoopAllActivities = 0x0FFFFFFFU
};

</code></pre>
<p>通过这些状态，我们可以判断出 Loop 正处于什么状态，并且可以根据状态不同而做相应的事件，比如监听 <code>kCFRunLoopBeforeWaiting</code>， 在这将在异步线程渲染好的UI在主线程进行更新，从而避免出现主线程阻塞，增加页面流畅度等等。</p>
<p>好了，相关的结构体已经介绍完</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[5月面试总结]]></title>
        <id>https://blog.wutao.xyz/post/5-yue-mian-shi-zong-jie/</id>
        <link href="https://blog.wutao.xyz/post/5-yue-mian-shi-zong-jie/">
        </link>
        <updated>2018-06-10T06:55:37.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="5月面试总结">5月面试总结</h1>
<blockquote>
<p>劳动节假期之后第一天，公司CEO开会宣布因为项目投入产出比没有达到预期，下一笔投资不会到账，公司资金链宣告断裂。我正式进入求职阶段。。。虽然说已经5月份了。。。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h1 id="5月面试总结">5月面试总结</h1>
<blockquote>
<p>劳动节假期之后第一天，公司CEO开会宣布因为项目投入产出比没有达到预期，下一笔投资不会到账，公司资金链宣告断裂。我正式进入求职阶段。。。虽然说已经5月份了。。。</p>
</blockquote>
<!-- more -->
<h3 id="前期准备">前期准备</h3>
<p>因为此次求职并不是主动的，来的比较突然，所以需要一些时间来梳理自己的知识体系，回顾一些基础的知识。于是花了几天时间熟悉面试题。</p>
<h3 id="简历投递顺序">简历投递顺序</h3>
<p>不要海投，不要海投，不要海投，重要的事情说三遍。<br>
先整体看一下最近的求职市场，学会评估哪些招聘是的确缺人，而哪些只是常年挂着。<br>
筛选出一些比较感兴趣的公司，列出优先级，由低到高，先投递一批，等到回复后再投递另一批，这样主要是为了给自己一些时间熟悉面试，毕竟不管怎样准备，总会有疏漏的地方，先通过面试一批公司，让自己尽快进入状态。</p>
<h3 id="简历投递渠道">简历投递渠道</h3>
<p>对于没有大厂经验的开发者来说，<strong>拉钩</strong> 并不是一个值得关注的地方，基本投递后了无音讯或者几天后标记为不合适。</p>
<p>论坛水友的内推，V2EX里企业HR的招聘贴，BOSS直聘都是不错的选择。作为参考，结合这求职期间的面试邀请,大致的比例是 2：2：6。</p>
<h3 id="关于简历内容">关于简历内容</h3>
<p>关于简历中的内容，我的建议是把自己能 show 的东西写出来，因为无论公司是否有 iOS 开发者，对于我们来说，第一关都是 HR，看似专业的术语会很大几率影响 HR 的判断，毕竟  ”iOS 程序员的简历是最多的“ 😂。<br>
当然，如果你能将简历直接递交到用人部门主管手中（包括邮箱，微信等等）那就再好不过了。</p>
<p>另一方面，我们不能为了秀而秀，单纯为了秀而不顾自己水平的乱写，我只能说陈独秀，你坐下。。。</p>
<p>任何关于招聘总结的帖子中，”熟悉简历中的技术点“ 永远都是最重要的点，你想，总不能被自己简历中的知识点难倒吧， 想想那尴尬的沉默。。。</p>
<p>只要你面试的不是实习生或者初级工程师， 那么你最好考虑一下自己的擅长方向，比如 UI精通，架构精通。因为开发者不可能只沉浸于业务，你得有一方面的专长，这是和其他竞争者拉开差距的地方，很不幸，我在本次的求职中，因为这个原因错失了两个还算不错的工作机会。</p>
<h3 id="关于面试过程">关于面试过程</h3>
<p>一天面试 1-2 家公司是比较合理的安排，不建议超过2家。经历有限，一家靠谱的公司，基本面试流程都在2个小时左右，早晨一家，面试完，吃个午饭休息一会，到另一家，这样时间还算是比较充裕，自己也有个缓冲时间，若一天都在赶着面试，那自己的状态又还有几分呢？</p>
<p>正常面试环节一般是 笔试-团队主程面-技术主管面-HR面， 完整是这样，但是根据每个公司不同的情况会有所筛减，不过 <strong>技术主管</strong> 和 <strong>HR</strong> 是必不可少的。</p>
<p>如果面试环节完整，那么有两个环节是必须重视的。</p>
<ul>
<li>
<p>团队主程面试<br>
在这一面中，你直接面对的就是今后的同事（当然前提是通过面试），这类人有个共同的特点-不希望招一个比平均水准差的。尽量减少团队的培训成本。都希望你是一个可以快速理解项目，快速加入开发流程的人。<br>
所以，你必须对他提到的问题做到 90% 的对答如流，要不然你可能进不了下一轮；</p>
</li>
<li>
<p>HR面<br>
在HR面中，其实没什么可说的，如果你足够优秀，那么不用担心，如果你只是在平均水准之上，那么你可能得给 HR 一个 <strong>稳定</strong> 的印象， 所谓 <strong>稳定</strong> 其实就是不要频繁跳槽，一般两年一次是在接受范围内。</p>
<p>最后，在每次面试结束后，一定要主动询问面试官，本次面试中，他觉得你比较不足的地方，这些能帮助你在后面的面试中，表现的更好。</p>
</li>
</ul>
<h3 id="关于最近的面试题">关于最近的面试题</h3>
<p>这半个月的面试过程中，主要涉及到下面的问题：</p>
<ul>
<li>各家组件化方案的优劣不同；</li>
<li>性能优化；</li>
<li>runtime相关原理；</li>
<li>weak的实现原理；</li>
<li>属性关键字修饰；</li>
<li>项目中关于网络层的优化；</li>
<li>Runloop相关；</li>
<li>多线程各种方案对比；</li>
<li>第三方库原理；</li>
<li>图片解码是干什么？</li>
<li>iOS中事件处理流程；</li>
<li>分类本质；</li>
<li>block相关；</li>
<li>锁相关；</li>
<li>kvo&amp;kvc；</li>
</ul>
<h3 id="总结">总结</h3>
<p>找工作真的很累，尤其是在5月。。。。<br>
关于知识积累，一定要注意平时容易忽略的地方，比如说 为什么 <strong>SDWebImage</strong> 中下载图片完成后需要将其解码？<br>
在可以快速高效完成日常业务后，一定要选择一个方向，要有所精通。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[简单的 JS 与 原生交互实现上传图片的需求]]></title>
        <id>https://blog.wutao.xyz/post/jian-dan-de-js-yu-yuan-sheng-jiao-hu-shi-xian-shang-chuan-tu-pian-de-xu-qiu/</id>
        <link href="https://blog.wutao.xyz/post/jian-dan-de-js-yu-yuan-sheng-jiao-hu-shi-xian-shang-chuan-tu-pian-de-xu-qiu/">
        </link>
        <updated>2018-04-08T06:58:47.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="前文">前文</h1>
<p>近期由于公司业务发展的需求，个人从 iOS开发 转为 半iOS 半前端😂。<br>
自学的坏处在于，有很多坑是要自己摔进去，再爬出来。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="前文">前文</h1>
<p>近期由于公司业务发展的需求，个人从 iOS开发 转为 半iOS 半前端😂。<br>
自学的坏处在于，有很多坑是要自己摔进去，再爬出来。</p>
<!-- more --> 
<h1 id="需求">需求</h1>
<p>将一个报修界面（类似于反馈）改版，并将新版界面的实现由原生迁移到H5。如下图<br>
<img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fpkdfswwxdj30po19gwjb.jpg" alt="img" loading="lazy"></p>
<p>现在的需求是，点击加号图片：</p>
<ul>
<li>调用系统拍照或者相册，然后将图片交给H5显示；</li>
<li>并在H5接收到时，进行阿里云 <code>OSS</code> 直传；</li>
</ul>
<h1 id="实现">实现</h1>
<h3 id="1-调用系统拍照或者相册然后将图片交给h5显示">1、调用系统拍照或者相册，然后将图片交给H5显示</h3>
<p>已知的方法有两种：</p>
<ol>
<li>使用<code>&lt;input&gt;</code>标签，使用H5直接调用（在iOS上可以调用，但在Android上无法调用，Pass）</li>
<li>使用 <code>JSBridge</code> 进行 js 与原生交互。</li>
</ol>
<p>现在的问题是选择一个兼容三端的JSBridge库（虽然原生都有方法进行交互，使用封装好的，更符合实际）。</p>
<p>恰好前段时间在掘金看到 <a href="https://github.com/wendux/DSBridge-IOS/blob/master/readme-chs.md">DSBridge</a>，学习了一下，所以这次就直接拿过来用了。</p>
<p>DSBridge 的使用，这里就不介绍了，可以直接点击👆的链接查看。</p>
<p>大致代码如下：</p>
<pre><code class="language-Objective-c">#JSAPI

// js 调用原生
- (NSString *)chooseImageFromMobile:(NSString *) msg {
  // 使用block回调，通知Controller
  if (self.chooseImage) {
    self.chooseImage();
  }
  return [msg stringByAppendingString:@&quot;[ syn call]&quot;];
}

- (NSString *)showRepairPendding:(NSString *) msg {
  [SVProgressHUD showWithStatus:@&quot;正在处理中...&quot;];
  return [msg stringByAppendingString:@&quot;[ syn call]&quot;];
}

// 服务端返回请求错误时， js调用原生
- (NSString *)showRepairError:(NSString *) msg {
  [SVProgressHUD showImage:nil status:msg];
  return [msg stringByAppendingString:@&quot;[ syn call]&quot;];
}

// 服务端返回报修成功时， js调用原生
- (NSString *)showRepairSuccess:(NSString *) msg {
  [SVProgressHUD dismiss];
  return [msg stringByAppendingString:@&quot;[ syn call]&quot;];
}
</code></pre>
<pre><code># ViewController


- (void)viewDidLoad {
    [super viewDidLoad];
  @weakify(self)
  self.repairApi.chooseImage = ^(){
    @strongify(self)
    [self changeHeader];
  };
    
}


- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info{
    @weakify(self);
  [picker dismissViewControllerAnimated:YES completion:^{
    @strongify(self)
    UIImage *icon = info[UIImagePickerControllerOriginalImage];
    NSData *imgData = UIImageJPEGRepresentation(icon,0.1);
    NSString *data = [imgData base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];
    // 将data拼接成 img src 能识别的标志。
    NSString *source = [NSString stringWithFormat:@&quot;data:image/png;base64,%@&quot;, data];
    [self.webView callHandler:@&quot;addPicture&quot; arguments:@[source] completionHandler:^(id  _Nullable value) {
      NSLog(@&quot;%@&quot;,value);
    }];
  }];
}

</code></pre>
<p>接下来只要在 js 中调用 OC 中的方法就可以了</p>
<pre><code class="language-JavaScript">
// 注册	addPicture 方法，接受从 OC 传过来的参数
dsBridge.register(&quot;addPicture&quot;, function(data) {
		// TODO
		// 从服务端获取直传 accessid 和 hosturl 等参数
	  return data;
});
        
</code></pre>
<h1 id="总结">总结</h1>
<p>这个需求的核心就是 JS 与 原生之间的交互，只要找对下手方向，那么剩下就是码代码了。</p>
]]></content>
    </entry>
</feed>